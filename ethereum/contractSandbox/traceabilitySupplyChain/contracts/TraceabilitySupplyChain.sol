pragma solidity 0.4.24;

/** 
* @dev Contract simulating traceability in supply chain management
* For now there will be single control authority for the entire Shipment contract. 
* Later on we can change it to per shipment level or something else
*/
contract TraceabilitySupplyChain {

    enum Status{ADDED, SHIPPED, RECEIVED, REFUNDED}

    struct Shipment {

        uint256 id;//Each shipment will have unique id which will be generated by the contract
        string name;//Name of the shipment
        address producer;// The producer of the shipment
        address shipper;// The shipper of the shipment
        address receiver;// The end customer of receiver of the shipment
        address sensor;// The wallet of unqiue sensor attached with the shipment. This sensor will be allowed to update tracking information about the shipment
        uint256 dateAdded;// Date when this shipment was added
        uint256 lastUpdated;// Date and time when the shipment was last updated
        string currentLatitude;//Current latitude of the shipment
        string currentLongitude;//Current longitude of the shipment
        Status status;//Current status of the shipment
        bytes metadata;// Other metadata about shipment
    }

    mapping(uint256=>Shipment) idVsShipment;


    uint256 public shipmentCount = 0;//Total number of shipments sent so far

    address public controlAuthority;//Wallet address of the control authority

    event ShipmentAdded(uint256 indexed id);

    event SensorPlaced(uint256 indexed id, address sensor);

    event LocationUpdated(uint256 indexed id, string latitude, string longitude);

    event StatusUpdated(uint256 indexed id, Status status);

    modifier nonZeroAddress(address _address){
        require(_address != address(0), "Zero address not acceptable");
        _;
    }

    modifier shipmentExists(uint256 shipmentId){
        require(idVsShipment[shipmentId].producer != address(0), "Shipment does not exists");
        _;
    }

    modifier onlyShipper(uint256 shipmentId){
        require(idVsShipment[shipmentId].shipper == msg.sender, "Unauthorized access");
        _;
    }

    modifier onlySensor(uint256 shipmentId){
        require(idVsShipment[shipmentId].sensor == msg.sender, "Unauthorized access");
        _;
    }

    modifier onlyReceiver(uint256 shipmentId) {
        require(idVsShipment[shipmentId].receiver == msg.sender, "Unauthorized access");
        _;
    }

    modifier inAddedState(uint256 shipmentId){
        require(idVsShipment[shipmentId].status == Status.ADDED, "Shipment not in ADDED state");
        _;
    }

    modifier inShippedState(uint256 shipmentId){
        require(idVsShipment[shipmentId].status == Status.SHIPPED, "Shipment not in SHIPPED state");
        _;
    }

    modifier onlyControlAuthority(){
        require(msg.sender == controlAuthority, "Unauthorized access");
        _;
    }   

    constructor(address _controlAuthority)public nonZeroAddress(_controlAuthority){
        
        controlAuthority = _controlAuthority;

    }

    /** 
    * @dev Add new shipment
    * @param shipper Wallet address of the shipper
    * @param receiver Wallet address of the receiver
    * @param name Name of the shipment
    * @param metaData Extra info about the shipment
    * The sender of this transaction will be considered as the producer of the shipment
    */
    function addShipment(string name, address shipper, address receiver, bytes metaData)external
     nonZeroAddress(shipper) nonZeroAddress(receiver){
        
        require(bytes(name).length>0, "Please provide name of the shipment");

        Shipment storage shipment = idVsShipment[shipmentCount];
        shipment.id = shipmentCount++;
        shipment.name = name;
        shipment.producer = msg.sender;
        shipment.shipper = shipper;
        shipment.receiver = receiver;
        shipment.dateAdded = block.timestamp;
        shipment.metadata = metaData;
        shipment.status = Status.ADDED;//New shipment, still not transported

        emit ShipmentAdded(shipment.id);
    }

    /** 
    * @dev The shipper of the shipment will be able to put sensor on the shipment. This sensor will be responsible for tranmitting location information
    * about shipment periodically to the blockchain
    * @param id Shipment id
    * @param sensor Wallet address of the sensor
    * Only shipper of the shipment can call this function
    */
    function putSensor(uint256 id, address sensor)external shipmentExists(id) onlyShipper(id) nonZeroAddress(sensor){
        
        Shipment storage shipment = idVsShipment[id];
        shipment.sensor = sensor;
        shipment.lastUpdated = block.timestamp;

        emit SensorPlaced(id, sensor);
    }

    /** 
    * @dev The sensor of the shipment will be able to update its location periodically
    * @param id Shipment id
    * @param latitude Current latitude of the shipment
    * @param longitude Current longitude of the shipment
    */
    function updateLocation(uint256 id, string latitude, string longitude)external shipmentExists(id) onlySensor(id){

        require(bytes(latitude).length > 0, "Latitude can't be empty");
        require(bytes(longitude).length > 0, "Longitude can't be empty");

        Shipment storage shipment = idVsShipment[id];
        shipment.currentLatitude = latitude;
        shipment.currentLongitude = longitude;
        shipment.lastUpdated = block.timestamp;

        emit LocationUpdated(id, latitude, longitude);
    }

    /** 
    * @dev Start the shipping of the shipment to be delivered to the receiver
    * @param id Shipment id
    * Only Shipper of the shipment can start the shipment
    * Sensor must be added before shipment can be started
    */
    function startShipment(uint256 id)external shipmentExists(id) onlyShipper(id) inAddedState(id){

        require(idVsShipment[id].sensor != address(0), "Please add sensor to the shipment before start");

        idVsShipment[id].status = Status.SHIPPED;

        idVsShipment[id].lastUpdated = block.timestamp;

        emit StatusUpdated(id, Status.SHIPPED);
    }
    

    /** 
    * @dev Receiver of the shipment can mark shipment as received, once received
    * @param id Shipment id
    */
    function receiveShipment(uint256 id)external
     shipmentExists(id) onlyReceiver(id) inShippedState(id){

        idVsShipment[id].status = Status.RECEIVED;

        idVsShipment[id].lastUpdated = block.timestamp;

        emit StatusUpdated(id, Status.RECEIVED);

    }

    /**
    * @dev Get information about the shipment
    * @param id Shipment id
    */
    function getShipmentInfo(uint256 id)external view returns
     (uint256 shipmentId, address producer, address shipper, address receiver, address sensor, uint256 dateAdded, uint256 lastUpdated, string currentLatitude, string currentLongitude, Status status, bytes metadata) {

        Shipment storage shipment = idVsShipment[id];

        shipmentId = shipment.id;
        producer = shipment.producer;
        shipper = shipment.shipper;
        receiver = shipment.receiver;
        sensor = shipment.sensor;
        dateAdded = shipment.dateAdded;
        lastUpdated = shipment.lastUpdated;
        currentLatitude = shipment.currentLatitude;
        currentLongitude = shipment.currentLongitude;
        status = shipment.status;
        metadata = shipment.metadata;
    }

    /** 
    * @dev Allows control autorhity to mark shipment as refunded in case producer/shipper is found at fault
    * @param id Shipment Id 
    */
    function refundShipment(uint256 id)external shipmentExists(id) onlyControlAuthority inShippedState(id){

        idVsShipment[id].status = Status.REFUNDED;

        idVsShipment[id].lastUpdated = block.timestamp;

        emit StatusUpdated(id, Status.REFUNDED);
    }

    /** 
    * @dev Check whether shipment exists
    * @param id Shipment Id
    */
    function checkShipment(uint256 id)external view returns(bool exists){

        exists = idVsShipment[id].producer != address(0);

    }
}